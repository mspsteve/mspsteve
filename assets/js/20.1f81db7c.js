(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{223:function(t,i,e){"use strict";e.r(i);var a=e(0),l=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,i=t.$createElement,e=t._self._c||i;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lock","aria-hidden":"true"}},[t._v("#")]),t._v(" lock")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#lock锁"}},[t._v("Lock锁")])]),e("li",[e("a",{attrs:{href:"#condition条件-实现锁的灵活性"}},[t._v("Condition条件(实现锁的灵活性)")])]),e("li",[e("a",{attrs:{href:"#conditionobject-继承condition"}},[t._v("ConditionObject 继承Condition")])]),e("li",[e("a",{attrs:{href:"#reentrantlock-继承lock"}},[t._v("ReentrantLock 继承Lock")])]),e("li",[e("a",{attrs:{href:"#readwritelock读写锁"}},[t._v("ReadWriteLock读写锁")])]),e("li",[e("a",{attrs:{href:"#reentrantreadwritelock可重入读写锁"}},[t._v("ReentrantReadWriteLock可重入读写锁")])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"lock锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lock锁","aria-hidden":"true"}},[t._v("#")]),t._v(" Lock锁")]),t._v(" "),e("ul",[e("li",[t._v("lock锁可以实现synchronized 关键字能实现相同的功能；lock锁的优势在于可以多个锁获取和释放顺序的灵活性。")]),t._v(" "),e("li",[t._v("lock() lockInterruptibly() 方法:\n"),e("ul",[e("li",[t._v("线程阻塞直到获取到锁；")]),t._v(" "),e("li",[t._v("lockInterruptibly() 线程中断会停止获取锁；")]),t._v(" "),e("li",[t._v("lockInterruptibly的某些实现会导致捕获不到中断？（到底是哪一个）")]),t._v(" "),e("li",[t._v("lockInterruptibly 方法需要处理检查异常或者死锁情况")])])]),t._v(" "),e("li",[t._v("tryLock()方法 同（2）；")]),t._v(" "),e("li",[t._v("unlock()方法释放锁会导致uncheck异常；")]),t._v(" "),e("li",[t._v("Condition是lock锁的边界；\n"),e("ul",[e("li",[t._v("thread获取lock，然后才可以调用condition.await()方法；")]),t._v(" "),e("li",[t._v("执行condition.await()方法，thread获取的lock锁会自动释放；")]),t._v(" "),e("li",[t._v("wait结果返回之前，可以重新获取lock,即condition没有阻塞之前，thread可以重新获取lock;")])])])]),t._v(" "),e("h2",{attrs:{id:"condition条件-实现锁的灵活性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#condition条件-实现锁的灵活性","aria-hidden":"true"}},[t._v("#")]),t._v(" Condition条件(实现锁的灵活性)")]),t._v(" "),e("ul",[e("li",[t._v("await() 、awaitUninterruptibly()、awaitNanos()、awaitUntil()")])]),t._v(" "),e("blockquote",[e("p",[t._v("Thread 阻塞在condition条件时，将释放锁；")])]),t._v(" "),e("ul",[e("li",[t._v("signal()、signalAll()唤醒线程时，将重新获取锁；")])]),t._v(" "),e("h2",{attrs:{id:"conditionobject-继承condition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conditionobject-继承condition","aria-hidden":"true"}},[t._v("#")]),t._v(" ConditionObject 继承Condition")]),t._v(" "),e("p",[t._v("Node类")]),t._v(" "),e("ul",[e("li",[t._v("使用nextWaiter，实现一个单向链表；")]),t._v(" "),e("li",[t._v("不同的Condition使用不同的单向链表；")]),t._v(" "),e("li",[t._v("进入链表后，会释放lock,从这里可以看出lock和condition使用不同的node;")]),t._v(" "),e("li",[t._v("await()方法调用以后，调用LockSupport.unpark方法终止阻塞，利用；")]),t._v(" "),e("li",[t._v("await()所有的线程都会进入队列中，循环阻塞的条件大于1；")]),t._v(" "),e("li",[t._v("await()--\x3e加入到awaiter队列---》释放锁--》判断是否为1，大于1阻塞（LockSupport.park），否则---》重新获取锁---》删除掉取消线程；")]),t._v(" "),e("li",[t._v("signal()方法移除头节点；")])]),t._v(" "),e("h2",{attrs:{id:"reentrantlock-继承lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock-继承lock","aria-hidden":"true"}},[t._v("#")]),t._v(" ReentrantLock 继承Lock")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("重入实现的原理")]),t._v(" "),e("ul",[e("li",[t._v("lock()---》acquire(1)---》tryAcquire---》")]),t._v(" "),e("li",[t._v("第一次获取锁时，设置排他线程，第N次进入时，将一直递增,最大值为整数的最大值；（同一个锁被多个方法使用，可以保证同一个线程中，不同方法间的调用）")]),t._v(" "),e("li",[t._v("lock.unlock时候，会减去1，直到减为0时，则设置线程为NULL;")])])]),t._v(" "),e("li",[e("p",[t._v("lock实现的原理")]),t._v(" "),e("ul",[e("li",[t._v("lock锁实现，利用设置线程与当前持有的线程做比较来实现唯一性；")]),t._v(" "),e("li",[t._v("lock锁实现过程中，获取不到锁，则会进入到双向链表队列（尾部进头部出）中----》进入后，会实现自旋--》当为第一个节点并且能获取到锁时，则会执行出队过程；")]),t._v(" "),e("li",[t._v("lock锁实现数据结构是双向链表，头节点是新增的节点，该节点和Condition的链表没有关系；")]),t._v(" "),e("li",[t._v("lock链表和condition实现的数据结构是一样的，仅此一点；")]),t._v(" "),e("li",[t._v("lock锁自旋时，shouldParkAfterFailedAcquire--\x3eparkAndCheckInterrupt：\n首先设置node节点为singal状态，然后设置线程为LockSupport.park,（线程会阻塞在这里，等待其他线程调用LockSupport.unpark）\n最后判断线程是否中断,若是中断，则清除中断；")]),t._v(" "),e("li",[t._v("清除中断的目的：\n执行线程节点的出队操作，然后再执行中断；"),e("br"),t._v("\n目的是确保线程执行中断，最终死亡；"),e("br"),t._v("\n如果在队列中，即使中断掉，也仅仅是设置中断状态变量，jvm虚拟机会判断是否执行相应的操作来确保安全退出")])])]),t._v(" "),e("li",[e("p",[t._v("unlock实现的原理\na、unlock---\x3erelease---\x3etryRelease---\x3eunparkSuccessor\ntryRelease 会变更 state值，移除线程;\nunparkSuccessor 传入头节点，唤醒第一个Thread,即（2）.f；")])]),t._v(" "),e("li",[e("p",[t._v("lockInterruptibly实现的原理")]),t._v(" "),e("ul",[e("li",[t._v("获取锁跟lock方法相同，不同点在于该方法会抛出线程中断，需要应用程序处理中断异常；")]),t._v(" "),e("li",[t._v("标准的中断异常处理方案：\nif (Thread.interrupted())    throw new InterruptedException();")])])]),t._v(" "),e("li",[e("p",[t._v("trylock()实现原理")]),t._v(" "),e("ul",[e("li",[t._v("判断是否获取到锁，并不会发生阻塞；")]),t._v(" "),e("li",[t._v("有方法可以实现中断相应；")])])]),t._v(" "),e("li",[e("p",[t._v("condition 和 ReentrantLock 实现的共同点：")]),t._v(" "),e("ul",[e("li",[t._v("使用相同的数据结构：node节点，均使用waitStatus字段；")]),t._v(" "),e("li",[t._v("不同点在于：condition 使用nextWaiter实现单向队列，ReentrantLock 使用prev和next实现双向队列；")])])]),t._v(" "),e("li",[e("p",[t._v("Sync---\x3eAbstractQueuedSynchronizer---\x3eAbstractOwnableSynchronizer (Node类的实现)")]),t._v(" "),e("ul",[e("li",[t._v("Node节点的状态\n"),e("ul",[e("li",[t._v("SIGNAL（-1）：该节点线程的后继线程会处于block，该节点cancel或者release时，需要唤醒后继节点")]),t._v(" "),e("li",[t._v("CANCELLED(1)：因为超时或中断，该线程已经被取消，")]),t._v(" "),e("li",[t._v("CONDITION(-2)：表明该线程被处于条件队列，因为调用Condition.await而被阻塞")]),t._v(" "),e("li",[t._v("PROPAGATE(-3)：传播共享锁")])])]),t._v(" "),e("li",[t._v("Node节点的模式: 共享模式（shared）和 独占模式（Exclusive）")])])]),t._v(" "),e("li",[e("p",[t._v("NonfairSync、FairSync---\x3eSync")]),t._v(" "),e("ul",[e("li",[t._v("NonfairSync 首先判断当前有线程获取到锁，如果没有获取到，则直接设置为当前线程；")]),t._v(" "),e("li",[t._v("FairSync 会判断队列里面是否有线程；")])])])]),t._v(" "),e("h2",{attrs:{id:"readwritelock读写锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readwritelock读写锁","aria-hidden":"true"}},[t._v("#")]),t._v(" ReadWriteLock读写锁")]),t._v(" "),e("ul",[e("li",[t._v("readLock()接口")]),t._v(" "),e("li",[t._v("writeLock()接口")])]),t._v(" "),e("h2",{attrs:{id:"reentrantreadwritelock可重入读写锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reentrantreadwritelock可重入读写锁","aria-hidden":"true"}},[t._v("#")]),t._v(" ReentrantReadWriteLock可重入读写锁")]),t._v(" "),e("ul",[e("li",[t._v("内部类：ReadLock() 和 WriteLock 均实现Lock接口；")]),t._v(" "),e("li",[t._v("writeLock()锁和ReadLock()锁数量的上限为：65535,\n"),e("ul",[e("li",[t._v("使用整型来处理无符号的短整型，其中高16位表示读锁的数量，低16位表示写锁的数量；")]),t._v(" "),e("li",[t._v("读状态：无符号右移16位：state >>> 16")]),t._v(" "),e("li",[t._v("写状态：高16位都和0按位与运算，抹去高16位：state & Ox0000FFFF")]),t._v(" "),e("li",[t._v("读状态加1：state + (1 << 16)")]),t._v(" "),e("li",[t._v("写状态加1：state + 1")]),t._v(" "),e("li",[t._v("判断写状态大于0，也就是写锁是已经获取： state & Ox0000FFFF > 0")]),t._v(" "),e("li",[t._v("判断读状态大于0，也就是读锁是已经获取：state != 0 && (state & Ox0000FFFF == 0)")])])])])])}],!1,null,null,null);l.options.__file="README.md";i.default=l.exports}}]);