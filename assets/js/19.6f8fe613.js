(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{226:function(e,t,a){"use strict";a.r(t);var r=a(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"executor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executor","aria-hidden":"true"}},[e._v("#")]),e._v(" executor")]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#execute接口方法"}},[e._v("Execute接口方法")])]),a("li",[a("a",{attrs:{href:"#executorservice-继承自execute接口"}},[e._v("ExecutorService 继承自Execute接口")])]),a("li",[a("a",{attrs:{href:"#future接口分析"}},[e._v("Future接口分析")])]),a("li",[a("a",{attrs:{href:"#locksupport（线程阻塞）"}},[e._v("LockSupport（线程阻塞）")])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"execute接口方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#execute接口方法","aria-hidden":"true"}},[e._v("#")]),e._v(" Execute接口方法")]),e._v(" "),a("p",[e._v("void execute(Runnable command);")]),e._v(" "),a("ul",[a("li",[e._v("该接口的中command可能会提交给以下三种方式中的线程\n"),a("ul",[a("li",[e._v("new thread")]),e._v(" "),a("li",[e._v("poolled thread")]),e._v(" "),a("li",[e._v("calling thread")])])]),e._v(" "),a("li",[e._v("可能会抛出异常\n"),a("ul",[a("li",[e._v("command null， throw NullExecuption")]),e._v(" "),a("li",[e._v("task 不能够被执行，则报RejectedExecutionException异常")])])]),e._v(" "),a("li",[e._v("可能是同步执行也可能是异步执行，取决于具体怎么去实现。")])]),e._v(" "),a("h2",{attrs:{id:"executorservice-继承自execute接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#executorservice-继承自execute接口","aria-hidden":"true"}},[e._v("#")]),e._v(" ExecutorService 继承自Execute接口")]),e._v(" "),a("ul",[a("li",[e._v("shutdown 方法保证执行的方法能够执行完毕（不再接受新任务），shutdownnow则暴力退出，isShutdown判断是否退出；")]),e._v(" "),a("li",[e._v("isTerminated用于判断shutdown 和 shutdownnow执行完后以后，任务是否完全执行完。这个任务是否包含队列中的任务？？？待定")]),e._v(" "),a("li",[e._v("awaitTermination 方法：任务执行完毕，超时，或者线程中断，会停止阻塞；")]),e._v(" "),a("li",[e._v("submit方法（会发生阻塞） 传值runnable需要指定Rusult的类型，因为runnable接口没有保存返回值，callable接口则不需要。Executo的内部静态类 RunnableAdapter中兼容一下runnable")]),e._v(" "),a("li",[e._v("invokeAll、invokeAny是同步方法，submit会发生阻塞")])]),e._v(" "),a("h2",{attrs:{id:"future接口分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#future接口分析","aria-hidden":"true"}},[e._v("#")]),e._v(" Future接口分析")]),e._v(" "),a("ul",[a("li",[e._v("cancel方法，isCancel、isDone方法\n"),a("ul",[a("li",[e._v("参数mayInterruptIfRunning，表示是否需要中断正在执行的任务；")]),e._v(" "),a("li",[e._v("接口方法实现需要定义task的状态。")]),e._v(" "),a("li",[e._v("已经取消、完成或者其他原因，返回false;")]),e._v(" "),a("li",[e._v("该接口执行完，isCancel 和isDone 返回true;")])])]),e._v(" "),a("li",[e._v("get方法，阻塞队列，使用头部插入到阻塞队列，删除节点的时候也是从头结点删除\n"),a("blockquote",[a("p",[e._v("延伸知识点：UNSAFE.park 线程挂起，线程将会阻塞到超时或者中断等条件出现。unpark终止挂起，恢复正常。")])])])]),e._v(" "),a("h2",{attrs:{id:"locksupport（线程阻塞）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#locksupport（线程阻塞）","aria-hidden":"true"}},[e._v("#")]),e._v(" LockSupport（线程阻塞）")]),e._v(" "),a("ul",[a("li",[e._v("unpark方法 和park方法（parkNanos、parkUntil、parkNanos）\n"),a("ul",[a("li",[e._v("park方法：阻塞线程，unpark方法：恢复正常")]),e._v(" "),a("li",[e._v("两个方法之间没有时序性；")]),e._v(" "),a("li",[e._v("park和unpark 方法：")])]),e._v(" "),a("blockquote",[a("p",[e._v("permit 许可通过变量_count 参数设置，unpark 方法设置为1，park方法会首先判断>0?，满足条件，返回：超时时，返回；其他情况阻塞；")])])]),e._v(" "),a("li",[e._v("getObjectVolatile是为了在不加锁的情况下保证数组中元素的一致性。")]),e._v(" "),a("li",[e._v("LockSupport.park是线程阻塞，Thread.interrupt是线程中断，从功能上讲LockSupport.park相当于Thread.wait();")])])])}],!1,null,null,null);i.options.__file="README.md";t.default=i.exports}}]);