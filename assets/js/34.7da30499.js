(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{194:function(a,t,v){"use strict";v.r(t);var _=v(0),r=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"jvm方法调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm方法调用","aria-hidden":"true"}},[a._v("#")]),a._v(" jvm方法调用")]),a._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#重载与重写"}},[a._v("重载与重写")]),v("ul",[v("li",[v("a",{attrs:{href:"#重载"}},[a._v("重载")])]),v("li",[v("a",{attrs:{href:"#重写"}},[a._v("重写")])])])]),v("li",[v("a",{attrs:{href:"#绑定基本概念"}},[a._v("绑定基本概念")]),v("ul",[v("li",[v("a",{attrs:{href:"#基本概念"}},[a._v("基本概念")])]),v("li",[v("a",{attrs:{href:"#调用指令引用解析"}},[a._v("调用指令引用解析")])])])]),v("li",[v("a",{attrs:{href:"#动态绑定"}},[a._v("动态绑定")]),v("ul",[v("li",[v("a",{attrs:{href:"#动态绑定"}},[a._v("动态绑定")])]),v("li",[v("a",{attrs:{href:"#区别"}},[a._v("区别")])]),v("li",[v("a",{attrs:{href:"#内联缓存"}},[a._v("内联缓存")])])])])])]),v("p"),a._v(" "),v("h2",{attrs:{id:"重载与重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重载与重写","aria-hidden":"true"}},[a._v("#")]),a._v(" 重载与重写")]),a._v(" "),v("h3",{attrs:{id:"重载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重载","aria-hidden":"true"}},[a._v("#")]),a._v(" 重载")]),a._v(" "),v("p",[a._v("  方法的名称相同，入参的类型不同，称之为重载。重载的方法在编译过程中可完成识别，选取过程共分为三个阶段，依次放开检测条件：")]),a._v(" "),v("ul",[v("li",[a._v("首先，不考虑对基本类型自动装拆箱（"),v("code",[a._v("auto-boxing")]),a._v("，"),v("code",[a._v("auto-unboxing")]),a._v("）以及可变长参数的情况下选取重载方法；")]),a._v(" "),v("li",[a._v("然后，在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；")]),a._v(" "),v("li",[a._v("最后，在允许自动装拆箱以及可变长参数的情况下选取重载方法；")])]),a._v(" "),v("h3",{attrs:{id:"重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重写","aria-hidden":"true"}},[a._v("#")]),a._v(" 重写")]),a._v(" "),v("p",[a._v("  子类中定义非中非私有同名方法，且两个方法的参数类型相同，则子类重写了父类的方法。")]),a._v(" "),v("h2",{attrs:{id:"绑定基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#绑定基本概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 绑定基本概念")]),a._v(" "),v("h3",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念","aria-hidden":"true"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),v("p",[a._v("  java虚拟机识别方法的关键在于类名、方法名以及方法描述符（"),v("code",[a._v("method descriptor")]),a._v("）。方法描述符是由方法的参数类型以及返回类型所构成。"),v("br"),a._v("\n  java虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。\njava字节码与调用相关的指令共有5种，具体如下：")]),a._v(" "),v("ul",[v("li",[a._v("invokestatic：调用静态方法")]),a._v(" "),v("li",[a._v("invokespecial：调用私有实例方法、构造器，以及使用"),v("code",[a._v("super")]),a._v("关键字调用父类的实例方法或构造器，和所实现接口的默认方法")]),a._v(" "),v("li",[a._v("invokevirtual：调用非私有实例方法")]),a._v(" "),v("li",[a._v("invokeinterface：调用接口方法")]),a._v(" "),v("li",[a._v("invokedynamic：调用动态方法")])]),a._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),v("p",[a._v("静态绑定包括：静态绑定包括：invokestatic指令、invokespecial指令对应的调用方法以及final标识的虚方法。其他均为动态调用。"),v("br")])]),a._v(" "),v("h3",{attrs:{id:"调用指令引用解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调用指令引用解析","aria-hidden":"true"}},[a._v("#")]),a._v(" 调用指令引用解析")]),a._v(" "),v("p",[a._v("  符号引用包括目标方法所在的类或者接口的名字，以及目标方法的方法名和方法描述符。符号引用存储在"),v("code",[a._v("class")]),a._v("文件的常量池中。\n根据目标方法是否为接口方法，可将引用分为接口引用和非接口引用。经过下面的接口引用和非接口解析步骤，会将符号引用解析成实际引用，静态绑定的方法调用被解析成\n一个指向方法的指针，动态绑定的方法引用则是一个方法表的索引。"),v("br")]),a._v(" "),v("p",[a._v("  非接口符号引用，假定该符号引用所指向的类为C,具体解析步骤如下：")]),a._v(" "),v("ul",[v("li",[a._v("在C中查找符合名字及描述符的方法。")]),a._v(" "),v("li",[a._v("如果没有找到，则在C的父类继续查找，直到"),v("code",[a._v("Object")]),a._v("类。")]),a._v(" "),v("li",[a._v("如果没有找到，在C所直接实现或者间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态。")])]),a._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),v("p",[a._v("间接实现的接口中的目标方法，需要满足C与目标接口之间没有其他符合条件的目标方法。"),v("br"),a._v("\n多个符合条件的目标方法，任意返回其中一个。")])]),a._v(" "),v("p",[a._v("  接口符号引用，假定该符合所指向的接口为I,具体解析步骤如下：")]),a._v(" "),v("ul",[v("li",[a._v("在I中查找符合名字及描述符的方法")]),a._v(" "),v("li",[a._v("如果没有找到，在"),v("code",[a._v("Object")]),a._v("类中的公有实例方法中搜索")]),a._v(" "),v("li",[a._v("如果没有找到，则在 I 的超接口中搜索。")])]),a._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),v("p",[a._v("这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。")])]),a._v(" "),v("h2",{attrs:{id:"动态绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态绑定","aria-hidden":"true"}},[a._v("#")]),a._v(" 动态绑定")]),a._v(" "),v("h3",{attrs:{id:"动态绑定-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态绑定-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 动态绑定")]),a._v(" "),v("p",[a._v("  java虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。方法表本质上市一个数组，\n每个数组元素指向一个当前类以及祖先类中非私有的实例方法。方法表满足两个特征：1、子类方法表中包含父类方法表中的所有方法；2、子类方法在方法表中的索引值\n与它所重写的父类方法索引值相同(继承关系的函数均为小数字索引值)。"),v("br"),a._v("\n  动态绑定：解析过程中，java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。")]),a._v(" "),v("h3",{attrs:{id:"区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 区别")]),a._v(" "),v("p",[a._v("  与静态绑定相比，动态绑定仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。\n相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。")]),a._v(" "),v("h3",{attrs:{id:"内联缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内联缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 内联缓存")]),a._v(" "),v("p",[a._v("  内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。解析过程中，如果查询到已缓存类型，内联缓存则直接调用，\n查询不到则退化到使用基于方法表的动态绑定，并且重新使用方法表进行动态绑定。\n  针对多态的内联缓存，为节省内存空间，java虚拟机目前只采用单态内联缓存。超多态的内联缓存，直接访问方法表，来实现动态绑定目标方法，节省写缓存的额外开销。")])])}],!1,null,null,null);r.options.__file="jvm方法调用原理.md";t.default=r.exports}}]);