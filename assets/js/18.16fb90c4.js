(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{229:function(e,r,a){"use strict";a.r(r);var t=a(0),l=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"thread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread","aria-hidden":"true"}},[e._v("#")]),e._v(" thread")]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#内部类state"}},[e._v("内部类State")])]),a("li",[a("a",{attrs:{href:"#isinterrupted-和interrupted-方法"}},[e._v("isInterrupted() 和interrupted()方法")])]),a("li",[a("a",{attrs:{href:"#parkblocker字段表示线程阻塞"}},[e._v("parkBlocker字段表示线程阻塞")])]),a("li",[a("a",{attrs:{href:"#线程的异常处理机制-uncaughtexceptionhandler"}},[e._v("线程的异常处理机制:UncaughtExceptionHandler")])]),a("li",[a("a",{attrs:{href:"#thread-parent-和threadgroup"}},[e._v("Thread parent  和ThreadGroup")])]),a("li",[a("a",{attrs:{href:"#interrupte-操作、blocker、blockerlock"}},[e._v("interrupte()操作、blocker、blockerLock")])]),a("li",[a("a",{attrs:{href:"#threadlocal-与-threadlocalmap-以及-thread的关系"}},[e._v("ThreadLocal 与 ThreadLocalMap 以及 Thread的关系")])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"内部类state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部类state","aria-hidden":"true"}},[e._v("#")]),e._v(" 内部类State")]),e._v(" "),a("ul",[a("li",[e._v("NEW：线程创建成功，尚未开始")]),e._v(" "),a("li",[e._v("RUNNABLE：线程正在正常运行中, 会等待操作系统资源的释放（IO等待、耗时计算、CPU时间切换）；")]),e._v(" "),a("li",[e._v("BLOCKED：阻塞状态\n"),a("ul",[a("li",[e._v("等待监视器（monitor）锁定，通常是synachronized 锁定的代码块或者synachronized 锁定可重入时调用的object.await();")]),e._v(" "),a("li",[e._v("线程在等待进入临界区；")])])]),e._v(" "),a("li",[e._v("WAITING：\n"),a("ul",[a("li",[e._v("调用Object.wait和Thread.join非超时状态以及LockSupport.park时，进入等待状态")]),e._v(" "),a("li",[e._v("与block的区别在于在等待其他线程notify 或者unpark；")])])]),e._v(" "),a("li",[e._v("IMED_WAITING\n"),a("ul",[a("li",[e._v("调用线程Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil时，超时处理；")]),e._v(" "),a("li",[e._v("与WAITING区别在于有超时；")])])]),e._v(" "),a("li",[e._v("TERMINATED: 线程执行结束；")])]),e._v(" "),a("h2",{attrs:{id:"isinterrupted-和interrupted-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isinterrupted-和interrupted-方法","aria-hidden":"true"}},[e._v("#")]),e._v(" isInterrupted() 和interrupted()方法")]),e._v(" "),a("ul",[a("li",[e._v("isInterrupted()判断线程是否发生中断；")]),e._v(" "),a("li",[e._v("interrupted()判断线程是否发生中断，若发生，则返回true，并清除中断状态；")]),e._v(" "),a("li",[e._v("interrupted() 和isInterrupted()\n"),a("ul",[a("li",[e._v("都是调用 native 方法：isInterrupted(boolean ClearInterrupted) ；")]),e._v(" "),a("li",[e._v("interrupted传true，isInterrupted()传false，其中true表示清除中断状态，false表示不清除")])])]),e._v(" "),a("li",[e._v("interrupte()调用时，线程的状态是Runnable;")]),e._v(" "),a("li",[e._v("线程的状态和中断状态是不同的变量来标识的；")])]),e._v(" "),a("h2",{attrs:{id:"parkblocker字段表示线程阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parkblocker字段表示线程阻塞","aria-hidden":"true"}},[e._v("#")]),e._v(" parkBlocker字段表示线程阻塞")]),e._v(" "),a("h2",{attrs:{id:"线程的异常处理机制-uncaughtexceptionhandler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程的异常处理机制-uncaughtexceptionhandler","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程的异常处理机制:UncaughtExceptionHandler")]),e._v(" "),a("ul",[a("li",[e._v("首先判断是否实现UncaughtExceptionHandler，如果实现则调用，否则调用ThreadGroup组的默认实现；")]),e._v(" "),a("li",[e._v("默认调用system.err记录日志错误信息；")])]),e._v(" "),a("h2",{attrs:{id:"thread-parent-和threadgroup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-parent-和threadgroup","aria-hidden":"true"}},[e._v("#")]),e._v(" Thread parent  和ThreadGroup")]),e._v(" "),a("ul",[a("li",[e._v("ThreadGroup 的功能\n"),a("ul",[a("li",[e._v("提供优先级、是否是驻守线程等功能；")]),e._v(" "),a("li",[e._v("提供基于线程状态的遍历;")]),e._v(" "),a("li",[e._v("提供线程报异常的默认处理方式；")])])]),e._v(" "),a("li",[e._v("线程的创建\n"),a("ul",[a("li",[e._v("线程创建时，使用currentThread()获取父线程，使用父线程的ThreadGroup来给新线程赋值；")])])]),e._v(" "),a("li",[e._v("线程启动\n"),a("ul",[a("li",[e._v("调用ThreadGroup.add方法，默认初始化4个线程数组，随后以2倍的方式递增；")]),e._v(" "),a("li",[e._v("线程的数量+1，未执行的数量减1；")]),e._v(" "),a("li",[e._v("线程移除时-1，未执行数量加1，然后copy，减少数组的量；")])])])]),e._v(" "),a("h2",{attrs:{id:"interrupte-操作、blocker、blockerlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interrupte-操作、blocker、blockerlock","aria-hidden":"true"}},[e._v("#")]),e._v(" interrupte()操作、blocker、blockerLock")]),e._v(" "),a("ul",[a("li",[e._v("interrupte()操作在blocker为空时，直接设置中断状态，并不是真正执行中断操作；")]),e._v(" "),a("li",[e._v("blockedOn 方法中给blocker赋值，当blocker不为空时，会真正调用OS内核操作，具体参见Java NIO")]),e._v(" "),a("li",[e._v("blockedOn 方法包级私有方法，对外不可见；")]),e._v(" "),a("li",[e._v("使用内部私有对象，使用隐性加锁；")]),e._v(" "),a("li",[e._v("默认情况下，线程创建以后，都不会给blocker赋值，所以中断以后参见（1）；")])]),e._v(" "),a("h2",{attrs:{id:"threadlocal-与-threadlocalmap-以及-thread的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-与-threadlocalmap-以及-thread的关系","aria-hidden":"true"}},[e._v("#")]),e._v(" ThreadLocal 与 ThreadLocalMap 以及 Thread的关系")]),e._v(" "),a("ul",[a("li",[e._v("ThreadLocal 与 ThreadLocalMap\n"),a("ul",[a("li",[e._v("ThreadLocalMap 是ThreadLocal 的内部静态类，其中基本的数据结构为Entry;")]),e._v(" "),a("li",[e._v("Entry继承自WeakReference< T >，其中使用super(ThreadLocal<?>)，因此Entry的key为弱引用，key的类型为ThreadLocal<?>;")]),e._v(" "),a("li",[e._v("Entry的value值为强引用；")])])]),e._v(" "),a("li",[e._v("Thread 有ThreadLocalMap对象，用于保存多个ThreadLocal;")]),e._v(" "),a("li",[e._v("使用弱引用的意义：\n"),a("ul",[a("li",[e._v("正常的hashMap，key 为强引用，所以不会gc回收；")]),e._v(" "),a("li",[e._v("ThreadLocalMap的值为若引用，所以key值在gc时候被回收；")]),e._v(" "),a("li",[e._v("ThreadLocal< T > threadLocal = new ThreadLocal()时候，threadLocal.set(key)，之所以new ThreadLocal()不会被回收，是因为有强引用的threadLocal指向；")])])]),e._v(" "),a("li",[e._v("inheritableThreadLocals 用于保存父线程的信息，可用于追踪。")])])])}],!1,null,null,null);l.options.__file="README.md";r.default=l.exports}}]);